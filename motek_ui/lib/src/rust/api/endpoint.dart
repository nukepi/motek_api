// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../api_handlers/attachments.dart';
import '../api_handlers/auth.dart';
import '../api_handlers/note_settings.dart';
import '../api_handlers/notebooks.dart';
import '../api_handlers/notes.dart';
import '../api_handlers/reminders.dart';
import '../api_handlers/shared_notes.dart';
import '../api_handlers/user_settings.dart';
import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `setup_logging`, `setup_multi_logging`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`

Future<AuthResponse> login({required String email, required String password}) =>
    RustLib.instance.api.crateApiEndpointLogin(
      email: email,
      password: password,
    );

Future<AuthResponse> register({
  required String email,
  required String password,
}) => RustLib.instance.api.crateApiEndpointRegister(
  email: email,
  password: password,
);

Future<List<Note>> listNotes() =>
    RustLib.instance.api.crateApiEndpointListNotes();

Future<Note?> getNote({required String noteId}) =>
    RustLib.instance.api.crateApiEndpointGetNote(noteId: noteId);

Future<Note?> createNote({required String title, required String content}) =>
    RustLib.instance.api.crateApiEndpointCreateNote(
      title: title,
      content: content,
    );

Future<Note?> updateNote({
  required String noteId,
  String? title,
  String? content,
}) => RustLib.instance.api.crateApiEndpointUpdateNote(
  noteId: noteId,
  title: title,
  content: content,
);

Future<bool> deleteNote({required String noteId}) =>
    RustLib.instance.api.crateApiEndpointDeleteNote(noteId: noteId);

Future<List<Notebook>> listNotebooks() =>
    RustLib.instance.api.crateApiEndpointListNotebooks();

Future<Notebook?> getNotebook({required String notebookId}) =>
    RustLib.instance.api.crateApiEndpointGetNotebook(notebookId: notebookId);

Future<Notebook?> createNotebook({required String name, String? parentId}) =>
    RustLib.instance.api.crateApiEndpointCreateNotebook(
      name: name,
      parentId: parentId,
    );

Future<Notebook?> updateNotebook({
  required String notebookId,
  String? name,
  String? parentId,
}) => RustLib.instance.api.crateApiEndpointUpdateNotebook(
  notebookId: notebookId,
  name: name,
  parentId: parentId,
);

Future<bool> deleteNotebook({required String notebookId}) =>
    RustLib.instance.api.crateApiEndpointDeleteNotebook(notebookId: notebookId);

Future<List<NoteSettings>> listNoteSettings({required String userId}) =>
    RustLib.instance.api.crateApiEndpointListNoteSettings(userId: userId);

Future<NoteSettings?> getNoteSettings({required String settingsId}) => RustLib
    .instance
    .api
    .crateApiEndpointGetNoteSettings(settingsId: settingsId);

Future<NoteSettings?> createNoteSettings({
  required String noteId,
  required String color,
  required String font,
  required String viewMode,
}) => RustLib.instance.api.crateApiEndpointCreateNoteSettings(
  noteId: noteId,
  color: color,
  font: font,
  viewMode: viewMode,
);

Future<NoteSettings?> updateNoteSettings({
  required String settingsId,
  String? color,
  String? font,
  String? viewMode,
}) => RustLib.instance.api.crateApiEndpointUpdateNoteSettings(
  settingsId: settingsId,
  color: color,
  font: font,
  viewMode: viewMode,
);

Future<bool> deleteNoteSettings({required String settingsId}) => RustLib
    .instance
    .api
    .crateApiEndpointDeleteNoteSettings(settingsId: settingsId);

Future<List<Attachment>> listAttachments() =>
    RustLib.instance.api.crateApiEndpointListAttachments();

Future<Attachment?> getAttachment({required String attachmentId}) => RustLib
    .instance
    .api
    .crateApiEndpointGetAttachment(attachmentId: attachmentId);

Future<Attachment?> createAttachment({
  required String noteId,
  required String filename,
  required String url,
}) => RustLib.instance.api.crateApiEndpointCreateAttachment(
  noteId: noteId,
  filename: filename,
  url: url,
);

Future<Attachment?> updateAttachment({
  required String attachmentId,
  String? filename,
  String? url,
}) => RustLib.instance.api.crateApiEndpointUpdateAttachment(
  attachmentId: attachmentId,
  filename: filename,
  url: url,
);

Future<bool> deleteAttachment({required String attachmentId}) => RustLib
    .instance
    .api
    .crateApiEndpointDeleteAttachment(attachmentId: attachmentId);

Future<List<Reminder>> listReminders({required String userId}) =>
    RustLib.instance.api.crateApiEndpointListReminders(userId: userId);

Future<Reminder?> getReminder({required String reminderId}) =>
    RustLib.instance.api.crateApiEndpointGetReminder(reminderId: reminderId);

Future<Reminder?> createReminder({
  required String noteId,
  required PlatformInt64 remindAt,
}) => RustLib.instance.api.crateApiEndpointCreateReminder(
  noteId: noteId,
  remindAt: remindAt,
);

Future<Reminder?> updateReminder({
  required String reminderId,
  bool? isDone,
  PlatformInt64? remindAt,
}) => RustLib.instance.api.crateApiEndpointUpdateReminder(
  reminderId: reminderId,
  isDone: isDone,
  remindAt: remindAt,
);

Future<bool> deleteReminder({required String reminderId}) =>
    RustLib.instance.api.crateApiEndpointDeleteReminder(reminderId: reminderId);

Future<List<SharedNote>> listSharedNotes({required String userId}) =>
    RustLib.instance.api.crateApiEndpointListSharedNotes(userId: userId);

Future<SharedNote?> getSharedNote({
  required String noteId,
  required String userId,
}) => RustLib.instance.api.crateApiEndpointGetSharedNote(
  noteId: noteId,
  userId: userId,
);

Future<SharedNote?> createSharedNote({
  required String noteId,
  required String userId,
  required String role,
}) => RustLib.instance.api.crateApiEndpointCreateSharedNote(
  noteId: noteId,
  userId: userId,
  role: role,
);

Future<SharedNote?> updateSharedNote({
  required String noteId,
  required String userId,
  required String role,
}) => RustLib.instance.api.crateApiEndpointUpdateSharedNote(
  noteId: noteId,
  userId: userId,
  role: role,
);

Future<bool> deleteSharedNote({
  required String noteId,
  required String userId,
}) => RustLib.instance.api.crateApiEndpointDeleteSharedNote(
  noteId: noteId,
  userId: userId,
);

Future<UserSettings?> getUserSettings({required String userId}) =>
    RustLib.instance.api.crateApiEndpointGetUserSettings(userId: userId);

Future<UserSettings?> createUserSettings({
  required String userId,
  required String lang,
  required String theme,
  required String timezone,
  required bool notificationsEnabled,
  required String defaultSort,
  required String editorMode,
}) => RustLib.instance.api.crateApiEndpointCreateUserSettings(
  userId: userId,
  lang: lang,
  theme: theme,
  timezone: timezone,
  notificationsEnabled: notificationsEnabled,
  defaultSort: defaultSort,
  editorMode: editorMode,
);

Future<UserSettings?> updateUserSettings({
  required String settingsId,
  String? lang,
  String? theme,
  String? timezone,
  bool? notificationsEnabled,
  String? defaultSort,
  String? editorMode,
}) => RustLib.instance.api.crateApiEndpointUpdateUserSettings(
  settingsId: settingsId,
  lang: lang,
  theme: theme,
  timezone: timezone,
  notificationsEnabled: notificationsEnabled,
  defaultSort: defaultSort,
  editorMode: editorMode,
);

Future<bool> deleteUserSettings({required String settingsId}) => RustLib
    .instance
    .api
    .crateApiEndpointDeleteUserSettings(settingsId: settingsId);

Future<bool> refreshTokens() =>
    RustLib.instance.api.crateApiEndpointRefreshTokens();

Future<void> configureLogging({
  required String logDir,
  required String logFilePrefix,
}) => RustLib.instance.api.crateApiEndpointConfigureLogging(
  logDir: logDir,
  logFilePrefix: logFilePrefix,
);

Future<CheckApiResult> checkApiConnection() =>
    RustLib.instance.api.crateApiEndpointCheckApiConnection();

Future<String> getLogs({String? logFilePath}) =>
    RustLib.instance.api.crateApiEndpointGetLogs(logFilePath: logFilePath);

Future<bool> setApiUrl({required String url}) =>
    RustLib.instance.api.crateApiEndpointSetApiUrl(url: url);

Future<String> getApiUrl() => RustLib.instance.api.crateApiEndpointGetApiUrl();

Future<void> testRustLogging() =>
    RustLib.instance.api.crateApiEndpointTestRustLogging();

Future<void> setFlutterLogCallback({
  required FnLevelStringMessageString callback,
}) => RustLib.instance.api.crateApiEndpointSetFlutterLogCallback(
  callback: callback,
);

Future<void> setupLoggingBridge({
  required String logLevel,
  String? logFilePath,
}) => RustLib.instance.api.crateApiEndpointSetupLoggingBridge(
  logLevel: logLevel,
  logFilePath: logFilePath,
);

Future<bool> isUserLoggedIn() =>
    RustLib.instance.api.crateApiEndpointIsUserLoggedIn();

Future<String?> getLoggedInEmail() =>
    RustLib.instance.api.crateApiEndpointGetLoggedInEmail();

Future<String?> getLoggedInUserId() =>
    RustLib.instance.api.crateApiEndpointGetLoggedInUserId();

Future<bool> logoutUser() => RustLib.instance.api.crateApiEndpointLogoutUser();

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<fn (level : String , message : String)>>
abstract class FnLevelStringMessageString implements RustOpaqueInterface {}

class CheckApiResult {
  final bool success;
  final int statusCode;
  final String message;

  const CheckApiResult({
    required this.success,
    required this.statusCode,
    required this.message,
  });

  @override
  int get hashCode => success.hashCode ^ statusCode.hashCode ^ message.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CheckApiResult &&
          runtimeType == other.runtimeType &&
          success == other.success &&
          statusCode == other.statusCode &&
          message == other.message;
}
